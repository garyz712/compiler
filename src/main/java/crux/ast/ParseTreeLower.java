package crux.ast;

import com.sun.jdi.IntegerType;
import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }

  public Type makeType(String name) {
    if (name.equals("int") ){
      return new IntType();
    }else if (name.equals("bool")){
      return new BoolType();
    }else if (name.equals("void")){
      return new VoidType();
    }
    throw new AssertionError("No type found");
  }

  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {
    ArrayList<Declaration> list = new ArrayList<Declaration> ();
    CruxParser.DeclListContext declListCxt = program.declList();

    for(CruxParser.DeclContext context: declListCxt.decl()) {
      Declaration node = context.accept(declVisitor);
      list.add(node);
    }

    return new DeclarationList(makePosition(declListCxt), list); // TODO Position? declListCxt or program

  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StmtList} AST object.
   */

  private StatementList lower(CruxParser.StmtListContext stmtList) {
    ArrayList<Statement> list = new ArrayList<Statement> ();

    for(CruxParser.StmtContext context: stmtList.stmt()) {
      Statement node = context.accept(stmtVisitor);
      list.add(node);
    }

    return new StatementList(makePosition(stmtList), list);

  }


  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StmtList} AST object.
   */
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    symTab.enter();
    StatementList stmtList = lower(stmtBlock.stmtList());
    symTab.exit();
    return stmtList;
  }

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VarariableDeclaration}
     *
     * @return an AST {@link VariableDeclaration}
     */


     @Override
     public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
      var name = ctx.Identifier().getText();
      String typeStr = ctx.type().Identifier().getText(); //TODO Identifier?
      Type type = makeType(typeStr);

      Position pos = makePosition(ctx);
      Symbol symbol = symTab.add(pos, name, type);
      return new VariableDeclaration(pos, symbol);
     }



    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     *
     * @return an AST {@link ArrayDeclaration}
     */

    @Override
    public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
      var name = ctx.Identifier().getText();
      String typeStr = ctx.type().Identifier().getText();
      Type eleType = makeType(typeStr);
      var type = new ArrayType(Long.parseLong(ctx.Integer().toString()), eleType);
      Position pos = makePosition(ctx);
      var symbol = symTab.add(pos, name, type);
      return new ArrayDeclaration(pos, symbol);
    }



    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     *
     * @return an AST {@link FunctionDefinition}
     */
     @Override
     public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
       String name = ctx.Identifier().getText();
       TypeList tl = new TypeList();
       String typeStr = ctx.type().Identifier().getText();
       Type returnType = makeType(typeStr);

       //System.out.println(typeStr);

       for (CruxParser.ParamContext pc: ctx.paramList().param()){
         String pctTypeStr = pc.type().Identifier().getText();
         Type pcType = makeType(pctTypeStr);
         tl.append(pcType);
       }
       Type type = new FuncType(tl, returnType);
       Position pos = makePosition(ctx);
       Symbol symbol = symTab.add(pos, name, type); //TODO scope?

       ArrayList<Symbol> sl = new ArrayList<Symbol> ();
       symTab.enter();
       for (CruxParser.ParamContext pc: ctx.paramList().param()){
         String pcName = pc.Identifier().getText();
         String pctTypeStr = pc.type().Identifier().getText();
         Position pos1 = makePosition(pc);
         Type pcType = makeType(pctTypeStr);
         Symbol symbol1 = symTab.add(pos1, pcName, pcType);
         sl.add(symbol1);
       }

       StatementList body = lower(ctx.stmtBlock());
       symTab.exit();
       return new FunctionDefinition(pos, symbol, sl, body);
     }

  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Stmt}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {


     @Override
     public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
       return declVisitor.visitVarDecl(ctx);

     }


    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */

     @Override
     public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
       Position pos = makePosition(ctx);
       Expression lhs = ctx.designator().accept(exprVisitor);
       Expression rhs = ctx.expr0().accept(exprVisitor);
       return new Assignment(pos, lhs, rhs);

     }


    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statementt}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     *
     * @return an AST {@link Call}
     */

     @Override
     public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {


          return exprVisitor.visitCallExpr(ctx.callExpr());

        }


    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */

     @Override
     public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
       Position pos = makePosition(ctx);
       Expression condition = ctx.expr0().accept(exprVisitor);
       StatementList thenBlock = lower(ctx.stmtBlock(0));
       StatementList elseBlock = ctx.stmtBlock().size() > 1 ? lower(ctx.stmtBlock(1)) : new StatementList(pos, new ArrayList<Statement>());
       return new IfElseBranch(pos, condition, thenBlock, elseBlock);
     }



    /**
     * Visit a parse tree for loop and create an AST {@link Loop}. You'll going to use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link Loop}
     */

     @Override
     public Statement visitLoopStmt(CruxParser.LoopStmtContext ctx) {

       // Create a position for the loop statement
       Position pos = makePosition(ctx);

       // Lower the stmtBlock context to an AST StatementList
       StatementList stmtList = lower(ctx.stmtBlock());

       // Create and return a new Loop node with the lowered statement list
       return new Loop(pos, stmtList); //TODO condition?
     }


    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */
    @Override
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      Expression expr = ctx.expr0().accept(exprVisitor);
      Position pos = makePosition(ctx);
      return new Return(pos, expr);

    }

    /**
     * Creates a Break node
     */
    @Override
    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      Position pos = makePosition(ctx);
      return new Break(pos);
    }

    /**
     * Creates a Continue node
     */
    @Override
    public Statement visitContinueStmt(CruxParser.ContinueStmtContext ctx) {
      Position pos = makePosition(ctx);
      return new Continue(pos);
    }
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
     @Override
     public Expression visitExpr0(CruxParser.Expr0Context ctx) {
       if (ctx.op0() == null) {
         return ctx.expr1(0).accept(exprVisitor);
       } else {
         //We expression1 op1 expression2 case
         Position pos = makePosition(ctx);
         Expression lhs = ctx.expr1(0).accept(exprVisitor);
         Expression rhs = ctx.expr1(1).accept(exprVisitor);
         CruxParser.Op0Context op0 = ctx.op0();
         String opStr = op0.getText();
         Operation operation;
         switch (opStr){
           case ">=":
             operation = Operation.GE;
             break;
           case "<=":
             operation = Operation.LE;
             break;
           case "!=":
             operation = Operation.NE;
             break;
           case "==":
             operation = Operation.EQ;
             break;
           case ">":
             operation = Operation.GT;
             break;
           case "<":
             operation = Operation.LT;
             break;
           default:
             throw new AssertionError("No operation 0 found");
         }

         return new OpExpr(pos, operation, lhs, rhs);
       }


     }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) {
        return ctx.expr2().accept(exprVisitor);
      } else {
        //We expression1 op1 expression2 case
        Position pos = makePosition(ctx);
        Expression lhs = ctx.expr1().accept(exprVisitor);
        Expression rhs = ctx.expr2().accept(exprVisitor);
        CruxParser.Op1Context op1 = ctx.op1();
        String opStr = op1.getText();
        Operation operation;
        switch (opStr) {
          case "+":
            operation = Operation.ADD;
            break;
          case "-":
            operation = Operation.SUB;
            break;
          case "||":
            operation = Operation.LOGIC_OR;
            break;
          default:
            throw new AssertionError("No operation 1 found");
        }

        return new OpExpr(pos, operation, lhs, rhs);
      }
    }


    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */

    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
        if (ctx.op2() == null) {
          return ctx.expr3().accept(exprVisitor);
        } else {
          //We expression1 op1 expression2 case
          Position pos = makePosition(ctx);
          Expression lhs = ctx.expr2().accept(exprVisitor);
          Expression rhs = ctx.expr3().accept(exprVisitor);
          CruxParser.Op2Context op2 = ctx.op2();
          String opStr = op2.getText();
          Operation operation;
          switch (opStr){
            case "*":
              operation = Operation.MULT;
              break;
            case "/":
              operation = Operation.DIV;
              break;
            case "&&":
              operation = Operation.LOGIC_AND;
              break;
            default:
              throw new AssertionError("No operation 2 found");
          }

          return new OpExpr(pos, operation, lhs, rhs);
        }
    }

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    //@Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
        if (ctx.designator() != null) {
          return ctx.designator().accept(exprVisitor);
        } else if (ctx.literal() != null) {
          return ctx.literal().accept(exprVisitor);
        } else if (ctx.expr3() != null) { //TODO correct?
          Position pos = makePosition(ctx);
          return new OpExpr(pos, Operation.LOGIC_NOT, ctx.expr3().accept(exprVisitor), null);
        } else if (ctx.callExpr() != null){
          return  ctx.callExpr().accept(exprVisitor);
        }
        else {
          return ctx.expr0().accept(exprVisitor);
        }

      }

    /**
     * Create an Call Node
     */
    @Override
    public Call visitCallExpr(CruxParser.CallExprContext ctx) {
      Position pos = makePosition(ctx);
      String name = ctx.Identifier().getText();
      Symbol symbol = symTab.lookup(pos, name);
      ArrayList<Expression> el = new ArrayList<Expression> ();

      for (CruxParser.Expr0Context ec: ctx.exprList().expr0()) {
          el.add(ec.accept(exprVisitor));
      }
      return new Call(pos, symbol, el);
    }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
        String name = ctx.Identifier().getText();
        Position pos = makePosition(ctx);
        Symbol symbol = symTab.lookup(pos, name);
        if (ctx.expr0()!= null) {
          Expression index = ctx.expr0().accept(exprVisitor);
          return new ArrayAccess(pos, symbol, index);
        }else{
          return new VarAccess(pos, symbol);
        }
    }


    /**
     * Create an Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      String number = ctx.getText();
      Position pos = makePosition(ctx);
      try {
        Integer.parseInt(number);
        Integer i = new Integer(number);
        return new LiteralInt(pos, i);
      } catch (NumberFormatException e) {
        Boolean i = new Boolean(number); //TODO correct?
        return new LiteralBool(pos, i);
      }

    }

  }
}
